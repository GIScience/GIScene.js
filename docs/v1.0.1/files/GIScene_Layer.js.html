<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>GIScene\Layer.js - GIScene 3D WebGIS API.</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="http://giscience.github.io/GIScene.js/images/GIScene-logo.png" title="GIScene 3D WebGIS API."></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/GIScene.html">GIScene</a></li>
                                <li><a href="../classes/GIScene.AspectMaterial.html">GIScene.AspectMaterial</a></li>
                                <li><a href="../classes/GIScene.Control.html">GIScene.Control</a></li>
                                <li><a href="../classes/GIScene.Control.AxisHelper.html">GIScene.Control.AxisHelper</a></li>
                                <li><a href="../classes/GIScene.Control.CameraLight.html">GIScene.Control.CameraLight</a></li>
                                <li><a href="../classes/GIScene.Control.Compass.html">GIScene.Control.Compass</a></li>
                                <li><a href="../classes/GIScene.Control.EdgeDetectionFreiChen.html">GIScene.Control.EdgeDetectionFreiChen</a></li>
                                <li><a href="../classes/GIScene.Control.Fly.html">GIScene.Control.Fly</a></li>
                                <li><a href="../classes/GIScene.Control.LoadIndicator.html">GIScene.Control.LoadIndicator</a></li>
                                <li><a href="../classes/GIScene.Control.Measure.html">GIScene.Control.Measure</a></li>
                                <li><a href="../classes/GIScene.Control.ObjectPosition.html">GIScene.Control.ObjectPosition</a></li>
                                <li><a href="../classes/GIScene.Control.OrbitZoomPan.html">GIScene.Control.OrbitZoomPan</a></li>
                                <li><a href="../classes/GIScene.Control.Pan.html">GIScene.Control.Pan</a></li>
                                <li><a href="../classes/GIScene.Control.PanOrbitZoomCenter.html">GIScene.Control.PanOrbitZoomCenter</a></li>
                                <li><a href="../classes/GIScene.Control.Pick.html">GIScene.Control.Pick</a></li>
                                <li><a href="../classes/GIScene.Control.Select.html">GIScene.Control.Select</a></li>
                                <li><a href="../classes/GIScene.Control.SSAO.html">GIScene.Control.SSAO</a></li>
                                <li><a href="../classes/GIScene.Control.TextPanel.html">GIScene.Control.TextPanel</a></li>
                                <li><a href="../classes/GIScene.Control.Trackball.html">GIScene.Control.Trackball</a></li>
                                <li><a href="../classes/GIScene.Control.Walk.html">GIScene.Control.Walk</a></li>
                                <li><a href="../classes/GIscene.Coordinate2.html">GIscene.Coordinate2</a></li>
                                <li><a href="../classes/GIscene.Coordinate3.html">GIscene.Coordinate3</a></li>
                                <li><a href="../classes/GIScene.DirectionMaterial.html">GIScene.DirectionMaterial</a></li>
                                <li><a href="../classes/GIScene.DistanceOpacityMaterial.html">GIScene.DistanceOpacityMaterial</a></li>
                                <li><a href="../classes/GIScene.Extent2.html">GIScene.Extent2</a></li>
                                <li><a href="../classes/GIScene.Format.html">GIScene.Format</a></li>
                                <li><a href="../classes/GIScene.GeoJSONLoader.html">GIScene.GeoJSONLoader</a></li>
                                <li><a href="../classes/GIScene.Grid.html">GIScene.Grid</a></li>
                                <li><a href="../classes/GIScene.Grid.Index.html">GIScene.Grid.Index</a></li>
                                <li><a href="../classes/GIScene.Layer.html">GIScene.Layer</a></li>
                                <li><a href="../classes/GIScene.Layer.Fixed.html">GIScene.Layer.Fixed</a></li>
                                <li><a href="../classes/GIScene.Layer.Grid.html">GIScene.Layer.Grid</a></li>
                                <li><a href="../classes/GIScene.Layer.Helper.html">GIScene.Layer.Helper</a></li>
                                <li><a href="../classes/GIScene.Layer.W3DS_0_4_0.html">GIScene.Layer.W3DS_0_4_0</a></li>
                                <li><a href="../classes/GIScene.Layer.W3DS_0_4_1.html">GIScene.Layer.W3DS_0_4_1</a></li>
                                <li><a href="../classes/GIScene.Line2.html">GIScene.Line2</a></li>
                                <li><a href="../classes/GIScene.LocalFileLoader.html">GIScene.LocalFileLoader</a></li>
                                <li><a href="../classes/GIScene.ModelLoader.html">GIScene.ModelLoader</a></li>
                                <li><a href="../classes/GIScene.OverrideMaterialHandler.html">GIScene.OverrideMaterialHandler</a></li>
                                <li><a href="../classes/GIScene.OverrideMaterialHandler.WMS.html">GIScene.OverrideMaterialHandler.WMS</a></li>
                                <li><a href="../classes/GIScene.PointAlignmentMaterial.html">GIScene.PointAlignmentMaterial</a></li>
                                <li><a href="../classes/GIScene.Process.html">GIScene.Process</a></li>
                                <li><a href="../classes/GIScene.Process.Intervisibility.html">GIScene.Process.Intervisibility</a></li>
                                <li><a href="../classes/GIScene.Process.LineOfSight.html">GIScene.Process.LineOfSight</a></li>
                                <li><a href="../classes/GIScene.Process.LineOfSight_fastClient.html">GIScene.Process.LineOfSight_fastClient</a></li>
                                <li><a href="../classes/GIScene.Process.LineOfSight_Layer.html">GIScene.Process.LineOfSight_Layer</a></li>
                                <li><a href="../classes/GIScene.Process.LineOfSight_simpleClient.html">GIScene.Process.LineOfSight_simpleClient</a></li>
                                <li><a href="../classes/GIScene.Process.LineOfSightNetwork_allToAll.html">GIScene.Process.LineOfSightNetwork_allToAll</a></li>
                                <li><a href="../classes/GIScene.RasterOverlayMaterial.html">GIScene.RasterOverlayMaterial</a></li>
                                <li><a href="../classes/GIScene.Scene.html">GIScene.Scene</a></li>
                                <li><a href="../classes/GIScene.Service.html">GIScene.Service</a></li>
                                <li><a href="../classes/GIScene.Service.W3DS_0_4_0.html">GIScene.Service.W3DS_0_4_0</a></li>
                                <li><a href="../classes/GIScene.Service.W3DS_0_4_1.html">GIScene.Service.W3DS_0_4_1</a></li>
                                <li><a href="../classes/GIScene.Style.html">GIScene.Style</a></li>
                                <li><a href="../classes/GIScene.Utils.html">GIScene.Utils</a></li>
                                <li><a href="../classes/GIScene.WMSOverlayMaterial.html">GIScene.WMSOverlayMaterial</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/GIScene.html">GIScene</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: GIScene\Layer.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Base class used for Layer classes
 * 
 * @namespace GIScene
 * @class Layer
 * @constructor
 * @param {String} name the layer name for display purposes
 * @param {Object} [config] the layer configuration object
 *  
 * @author mcauer https://github.com/mcauer
 */

GIScene.Layer = function (name, config) {
	
	//Layer properties
	var defaults = {
		
		id:null, //@TODO create unique Ids that can be overridden by a user config
		
		//appearance
		visibility : true, 
		
		opacity : 1,		
		overrideMaterial:null, 
		//
		projection : null,
		
		offset: new GIScene.Coordinate3(0,0,0),
		
		listeners	:[],
		
		styles		:[], //container for optional styles (overrideMaterials)
		
		//remoteAttributes vs. localAttributes
		//attributeService:{
			// baseURL,
			// singleObjectSchema: ?layer=abc&amp;q={id} || /{id} etc  (id has to be a field) 
			// pagingSchema: ?layer=abc&amp;pageFrom={pageFrom}&amp;pageTo={pageTo}
		// }
		attributeReader : null, //object with function to fill data into the object attributes
		// {
			// &#x27;geom_id&#x27;:  function(object){return (object.name.split(&#x27;_&#x27;)[1]) || null;},
			// &#x27;attr_id&#x27;:  function(object){return (object.name.split(&#x27;_&#x27;)[2]) || null;},
			// &#x27;nodetype&#x27;: function(object){return (object.name.split(&#x27;_&#x27;)[0]) || null;},
// 		
		// },
		
		properties:{
			fields:[
			//{name:&#x27;geom_id&#x27;, alias:&#x27;Geometry ID&#x27;, type:&#x27;int&#x27;, comment:&#x27;&#x27;}
			//{name:&#x27;attr_id&#x27;, alias:&#x27;Attribute ID&#x27;, type:&#x27;int&#x27;, comment:&#x27;&#x27;}
			//{name:&#x27;nodetype&#x27;, alias:&#x27;Node Type&#x27;, type:&#x27;text&#x27;, comment:&#x27;&#x27;}
			],
			//primaryKey:&#x27;geom_id&#x27; //is unique and not null
		},
		attributeTable:[
			//{geom_id:13}
		]
		
	};
	
	this.config = GIScene.Utils.mergeObjects(defaults, config || {});
	
	this.id	= this.config.id || GIScene.idCounter++; //  null; //@TODO create unique Ids
	
	this.name = null;
	
	this.offset = null; //GIScene.Coordinate3()
	
	var translateLayer = null; //THREE.Vector3()  will be computed automatically onSetScene
	
	this.root = null; //should be a THREE.Scene() Object
	
	this.scene = null;
	
	this.loader = null;
	
	this.visibility = null;
	
	this.selectControl = null; //set on setScene
	
	this.attributeReader = null;
	
	this.selectionQueryStack = null; //will hold an array of queryObjects to be processed sequentially
	
	var defaultStyle = new GIScene.Style({title: &#x27;default style&#x27;, material: this.config.overrideMaterial});
	
	this.styles = [defaultStyle];
	Array.prototype.push.apply(this.styles, this.config.styles);
	
	this.init = function(){
		//@TODO create unique Id
		
		this.name = name;
		this.root = new THREE.Scene();
		this.root.name = &#x27;layer&#x27; + ((this.name)? &quot;_&quot;+this.name : &quot;&quot;);
		this.offset = this.config.offset;
		this.loader = new GIScene.ModelLoader();
		this.attributeReader = this.config.attributeReader;
		
		//@TODO check visibility onload
		this.visibility = this.config.visibility;
		
	};
	
	this.add = function(node, parent){
		parent.add(node);
	};
	
	this.remove = function(node){
		node.parent.remove(node);
	};
	
	this.setScene = function(scene){
		this.scene = scene;
		/**
		 *@event setScene
		 */
		this.dispatchEvent({
			type : &#x27;setScene&#x27;, content:scene
		});
	};
	

	
	/**
	 * Sets the opacity value for the whole layer
	 * 
	 * @method setOpacity
	 * @param {Number} opacity
	 */
	this.setOpacity = function(opacity) { 
		
		this.root.traverse(function(object) {

			GIScene.Utils.WorkingMaterial.setOpacity(object,opacity);

			// if (object.material &amp;&amp; !(object instanceof THREE.Sprite)) {
				// if(!object.userData.originalMaterial){
					// // if no working material exists create one 
					// object.userData.originalMaterial = object.material;
					// object.material = object.userData.originalMaterial.clone();
					// //set flag
					// object.userData.workingMaterialFlags = GIScene.WORKINGMATERIALFLAGS.OPACITY;
				// }
// 				
				// //no wm --&gt; create and set flag and mode
// 					
				// //else wm exists --&gt; check if new mode == original
				// /*else*/ if (opacity == object.userData.originalMaterial.opacity || opacity == &#x27;default&#x27;){
					// //remove (toggle) flag
					// object.userData.workingMaterialFlags ^= GIScene.WORKINGMATERIALFLAGS.OPACITY;	
				// }
// 								
				// //set property
				// if(opacity == &#x27;default&#x27;){
					// object.material.opacity = object.userData.originalMaterial.opacity;
					// object.material.transparent = (object.material.opacity &lt; 1 ) ? true : false;
					// object.material.depthTest = (object.material.opacity &lt; 1 ) ? false : true;
				// }
				// else{
					// object.material.opacity = opacity * object.userData.originalMaterial.opacity;
					// object.material.transparent = (object.material.opacity &lt; 1 ) ? true : false;
					// object.material.depthTest = (object.material.opacity &lt; 1 ) ? false : true;
				// }
// 					
				// //check if wm still in use --&gt; false remove wm and switch to orignal
				// if(object.userData.workingMaterialFlags == 0){
						// //change back to original material
						// object.material = object.userData.originalMaterial;
						// object.userData.originalMaterial = null;
						// delete object.userData.originalMaterial;
				// }
// 				
			// }
		}
		);
	};
	
		/**
	 * add a style to the layers styles list
	 * @method addStyle 
 	 * @param {GIScene.Style} style
	 */
	this.addStyle = function(style) {
		this.styles.push(style);
		/**
		 *@event addStyle 
		 */
		this.dispatchEvent({type:&#x27;addStyle&#x27; , content:{layer:this, style: style}});
	};
	
	/**
	 * remove an existing style from the layers style list 
 	 * @method removeStyle
 	 * @param {GIScene.Style} style
	 */
	this.removeStyle = function(style){
		for (var i = 0, l = this.styles.length; i&lt;l; i++){
			if (this.styles[i] === style){ 
			
				this.styles.splice(i,1); 
				/**
				 *@event removeStyle 
				 */
				this.dispatchEvent({type:&#x27;removeStyle&#x27; , content:{layer:this, style: style}});
			}
		}
	};
	
	/**
	 * remove style, its material and textures from memory 
	 * @method disposeStyle
	 * @param {GIScene.Style} style
	 */
	this.disposeStyle = function(style){
		
		this.removeStyle(style);
		
		var materials = [], textures=[];
		//get materials
		if (style.material) {
				if (style.material instanceof THREE.MeshFaceMaterial) {
					style.material.materials.forEach(function(material) {
						if (! GIScene.Utils.arrayContains(materials, material)) {
							materials.push(material);
						};
					});
				} else {

					if (! GIScene.Utils.arrayContains(materials, style.material)) {
						materials.push(style.material);
					};
				}
			}
		
		//get textures
		materials.forEach(function(material) {
			var maps = [&quot;map&quot;, &quot;lightMap&quot;, &quot;bumpMap&quot;, &quot;normalMap&quot;, &quot;specularMap&quot;, &quot;envMap&quot;, &quot;texture&quot;]; //texture exists in RasterOverlayMaterial
			for (var i = 0, j = maps.length; i &lt; j; i++) {
				if (material[maps[i]] &amp;&amp; material[maps[i]] != null &amp;&amp; ! GIScene.Utils.arrayContains(textures, material[maps[i]])) {
					textures.push(material[maps[i]]);
				};
			};
		}); 
	
		//dispose textures, materials
		textures.forEach(function (texture) {
		  texture.dispose();
		});
		textures = null;
		
		materials.forEach(function (material) {
		  material.dispose();
		});
		materials = null;
		
		delete style.material;
		style = null;	
		
	};
	
	//@TODO destroy function to remove everything from memory --&gt; now implemented Scene.disposeLayer()
	
	//start auto initialization 
	this.init();
	
	// when added to a scene 
	var onSetScene = function(event) {
		var scene = event.content;
		this.offset = this.config.offset;
		translateLayer = (scene) ? this.offset.toVector3().sub(scene.config.offset.toVector3())
								 : new THREE.Vector3();
								 ;
		this.root.position = translateLayer;
		this.root.updateMatrix();
		this.root.updateMatrixWorld();
		console.log(&quot;translateLayer: &quot;+translateLayer.toArray());
		
		//configure select control
		if(scene){
			this.selectControl = new GIScene.Control.Select([],scene.camera,{multi:true, selectColor: 0xff8000});
			this.selectControl.selectables = this.root.getDescendants();	
			scene.addControl(this.selectControl);
			
			var onBeforeRemove = function(event) {
				if(event.content === this){
					scene.removeControl(this.selectControl);
					this.selectControl.selectables = [];
					this.selectControl = null;
					scene.removeEventListener(&#x27;beforeremovelayer&#x27;, onBeforeRemove);
				}
			}.bind(this);
			scene.addEventListener(&#x27;beforeremovelayer&#x27;, onBeforeRemove);
		}
		
		//@TODO implement selectables update according to LayerType (Fixed, Grid)
	}.bind(this);
	this.addEventListener(&#x27;setScene&#x27;, onSetScene);
};

//Provide EventDispatcher Functions
GIScene.Layer.prototype = {
	
	constructor : GIScene.Layer,
	
	/**
	 * get Objects by a evaluation function which recursively tries to match the objects of the layer
	 * 
	 * @method getObjectsBy
	 * @param {Function} callback
	 * @return {Array} matches
	 */
	getObjectsBy : function(callback) {
		return GIScene.Utils.getObjectsBy(this.root,callback);
	},
	
	/**
	 * set or modify the current layer selection by attribute query
	 * 
	 * @method selectByAttributes
	 * @param {String} attributeName must be available in object.userData.gisceneAttributes
	 * @param {String} operator defines how to compare the given values with the object attributes
	 * @param {Mixed} value the values for the selection criteria
	 * @param {String} selectMode can be new,add,sub,intersect
	 * 
	 * @example
	 * 	{
	 * 		&quot;attributeName&quot; : &quot;attr_id&quot;,
	 * 		&quot;operator&quot;		: &quot;IN&quot;, //&quot;==&quot;,&quot;!=&quot; .... TODO
	 * 		&quot;value&quot;			: [2393,1234],
	 * 		&quot;selectMode&quot;	: &quot;new&quot;
	 * 	}
	 * 
	 */
	
	selectByAttributes : function(queryObjectStack, root, interaction) {
		
		var root = (!root)? this.root : root;
		
		this.selectionQueryStack = (queryObjectStack instanceof Array)? queryObjectStack : [queryObjectStack];
		
		for(var i=0,j=this.selectionQueryStack.length; i&lt;j; i++){
		  	
		  	var queryObject = this.selectionQueryStack[i];
		
			var attr 		= queryObject.attributeName;
			var operator 	= queryObject.operator;
			var value		= queryObject.value;
			var selectMode	= queryObject.selectMode || &quot;new&quot;; //defaults to &quot;new&quot;
			
			var queryResults=[];
			
			//operator functions
			var equals_to = function(object,attr,value) {
				return object.userData.gisceneAttributes[attr] == value;
			}; 
			var contains = function(object,attr,value) { //contains
				var regExp = new RegExp(String(value), &quot;gi&quot;);
				return regExp.test(String(object.userData.gisceneAttributes[attr]));
			}; 
	
			
			switch (operator){
				case &quot;EQUALS_TO&quot; || &quot;==&quot;:
							queryResults = GIScene.Utils.getObjectsBy(root,function(object){
								return equals_to(object,attr,value);
							});
							break;
				case &quot;IN&quot;:
							for(var i=0,j=value.length; i&lt;j; i++){
							    var tempResults = GIScene.Utils.getObjectsBy(root,function(object){
							  	return equals_to(object,attr,value[i]);
							  }); 
							  Array.prototype.push.apply(queryResults, tempResults);
							};
							break;
				case &quot;CONTAINS&quot; || &quot;~&quot;:
							queryResults = GIScene.Utils.getObjectsBy(root,function(object){
								return contains(object,attr,value);
							});
							break; 
			}
		   
		   //select
		   switch (selectMode){
		   	case &quot;new&quot;: 
		   				root.traverse(function(object){
		   					if(object.userData.isSelected){
		   						this.selectControl.unselect(object,interaction);
		   					}
		   				}.bind(this));
		   				//this.selectControl.unselectAll();
		   				
		   				for(var i=0,j=queryResults.length; i&lt;j; i++){
							 this.selectControl.select( queryResults[i],interaction );
						   };
		   				break;
		   	case &quot;add&quot;:
		   				var temp_toggleValue = this.selectControl.config.toggle;
		   				this.selectControl.config.toggle = false;
		   				for(var i=0,j=queryResults.length; i&lt;j; i++){
							this.selectControl.select( queryResults[i],interaction );
						   };
						this.selectControl.config.toggle = temp_toggleValue;
		   				break;
		   }
		};
	},
	
	//@TODO add parameter {Array} ids to apply override Material only to the matched ids for coloring by Attributes
	//@TODO removeOverrideMaterial
	setOverrideMaterial : function(node, overrideMaterial, keepWorkingMaterialProperties) {
		
		var keepWorkingMaterialProperties = keepWorkingMaterialProperties || true;
				
		if(overrideMaterial instanceof THREE.Material || !overrideMaterial){
			//update properties
			this.config.overrideMaterial = overrideMaterial;
			//rescursively apply overrideMaterial
			node.traverse(
				function(obj) {
					if(obj.material){
						/**
						 *@event beforeSetOverrideMaterial
						 */
						this.dispatchEvent({
							type : &#x27;beforeSetOverrideMaterial&#x27;, content:{object: obj, overrideMaterial: overrideMaterial, layer: this}
						});
						
						//set overrideMaterial
						
						if(overrideMaterial){
							//store original material the first time
							if(!obj.userData.overriddenMaterial){
								obj.userData.overriddenMaterial = obj.material; //@TODO maybe better check for original material, in case material has already been changed by workingMaterial properties
							}
							else
							{
								//dispose overridden material
								if(obj.material.isShared === false){ // === important for not evaluating undefined
									GIScene.Utils.disposeObject(obj, false, true, true);
								 }
							}
							
							//if keep WM props
							//collect props
							if(keepWorkingMaterialProperties) {var workingMaterialProperties = GIScene.Utils.WorkingMaterial.getValues(obj);}
							
							//cleanup
							delete obj.userData.originalMaterial;
							obj.userData.workingMaterialFlags = 0;
							
							//assign new override material
							obj.material = this.config.overrideMaterial;
							
							//if keep WM props
							//reassign WM props
							if(keepWorkingMaterialProperties) {GIScene.Utils.WorkingMaterial.setValues(obj, workingMaterialProperties);}
							
						}
						//remove overrideMaterial
						else{
							if(obj.userData.overriddenMaterial &amp;&amp; obj.userData.overriddenMaterial instanceof THREE.Material){
								obj.material = obj.userData.overriddenMaterial;
								delete obj.userData.overriddenMaterial;
							}
							
						}
						
						
						
						/**
						 *@event afterSetOverrideMaterial
						 */
						this.dispatchEvent({
							type : &#x27;afterSetOverrideMaterial&#x27;, content:{object: obj, overrideMaterial: overrideMaterial, layer: this}
						});
					}
					
					if(this.config.overrideMaterial &amp;&amp; this.config.overrideMaterial.shading == THREE.SmoothShading &amp;&amp; obj.geometry &amp;&amp; (!obj.geometry.normals || obj.geometry.normals.length == 0)){
						obj.geometry.computeVertexNormals();
					}
					
				}.bind(this)
			);
		}
	},
	
	setVisibility : function(visibility){
		this.root.traverse(
			function(obj){
				obj.visible = visibility;
			}
		);
		this.visibility = visibility;
		/**
		 *@event changedvisibility
		 *listener function will get the following event object as argument 
		 *@example
		 * 	eventObject = {
		 * 		content:{
		 * 			layer:{GIScene.Layer}, 
		 * 			visibility:{Boolean}
		 * 		}
		 * 	}			
		 */
		this.dispatchEvent({type:&#x27;changedvisibility&#x27;, content:{layer:this, visibility:this.visibility}});
	},
	
	showAttributeTable : function() {
		//@TODO showAttributeTable
	},
	
	/**
	 * @method getAttributeNames
	 * @return {Array(String)} attributeNames
	 */
	getAttributeNames : function() {
		var attributeNames = [];
		this.root.traverse(function(object){
			if(object.userData.gisceneAttributes &amp;&amp; Object.keys(object.userData.gisceneAttributes).length &gt; 0 ){
				return attributeNames = Object.keys(object.userData.gisceneAttributes);
			}
		});
		return attributeNames;
	},
	
	getExampleValues : function() {
		var exampleValues = [];
		this.root.traverse(function(object){
			if(object.userData.gisceneAttributes &amp;&amp; Object.keys(object.userData.gisceneAttributes).length &gt; 0 ){
				exampleValues = [];
				for (attr in object.userData.gisceneAttributes){
					exampleValues.push(object.userData.gisceneAttributes[attr]);
				}
				return exampleValues;
			}
		}.bind(this));
		return exampleValues;
	},
	
	/**
	 * apply a style to the layer 
	 * @method setActiveStyle
 	 * @param {GIScene.Style} style
	 */
	setActiveStyle : function(style) {
		
		if( !style ||  (typeof style == &#x27;string&#x27; &amp;&amp; style.toLowerCase() == &quot;default&quot;) ){
			style = this.styles[0];
		}
		
		var recursive = style.recursive; //TODO implement recursive as parameter of setOverrideMaterial
		
		var material = style.material;
		
		var selectionType = (style.rootObjects)? &quot;byObjects&quot; : (style.rootObjectKeyAttribute)? &quot;byAttributes&quot; : &quot;selectAll&quot;;
		
		if(selectionType == &quot;selectAll&quot;){
			
			this.setOverrideMaterial(this.root, material);
			
		}
		
		if(selectionType == &quot;byObjects&quot;){
			
			var objects = style.rootObjects;
			
			//first reset all objects to default material
			
			//second style selected objects with other material
			for(var i=0,j=objects.length; i&lt;j; i++){
				
				this.setOverrideMaterial(objects[i], material);
			  
			};
			
		}
		
		if(selectionType == &quot;byAttributes&quot;){
			//@TODO
			console.log(&quot;Layer.setActiveStyle(): style objects by attributes not yet implemented&quot;);
		
		}
		
		/**
		 *@event setActiveStyle 
		 */
		this.dispatchEvent( { type : &#x27;setActiveStyle&#x27;, content : { layer:this, style: style } } );
	
	},
	
	addEventListener: THREE.EventDispatcher.prototype.addEventListener,
	hasEventListener: THREE.EventDispatcher.prototype.hasEventListener,
	removeEventListener: THREE.EventDispatcher.prototype.removeEventListener,
	dispatchEvent: THREE.EventDispatcher.prototype.dispatchEvent
	
};
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
