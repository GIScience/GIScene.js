<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>GIScene\Process\LineOfSight_simpleClient.js - GIScene 3D WebGIS API.</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="..\..\lib\resources\images\GIScene-logo.png" title="GIScene 3D WebGIS API."></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/GIScene.html">GIScene</a></li>
                                <li><a href="../classes/GIScene.AspectMaterial.html">GIScene.AspectMaterial</a></li>
                                <li><a href="../classes/GIScene.Control.html">GIScene.Control</a></li>
                                <li><a href="../classes/GIScene.Control.AxisHelper.html">GIScene.Control.AxisHelper</a></li>
                                <li><a href="../classes/GIScene.Control.CameraLight.html">GIScene.Control.CameraLight</a></li>
                                <li><a href="../classes/GIScene.Control.Compass.html">GIScene.Control.Compass</a></li>
                                <li><a href="../classes/GIScene.Control.EdgeDetectionFreiChen.html">GIScene.Control.EdgeDetectionFreiChen</a></li>
                                <li><a href="../classes/GIScene.Control.Fly.html">GIScene.Control.Fly</a></li>
                                <li><a href="../classes/GIScene.Control.LoadIndicator.html">GIScene.Control.LoadIndicator</a></li>
                                <li><a href="../classes/GIScene.Control.Measure.html">GIScene.Control.Measure</a></li>
                                <li><a href="../classes/GIScene.Control.ObjectPosition.html">GIScene.Control.ObjectPosition</a></li>
                                <li><a href="../classes/GIScene.Control.OrbitZoomPan.html">GIScene.Control.OrbitZoomPan</a></li>
                                <li><a href="../classes/GIScene.Control.Pan.html">GIScene.Control.Pan</a></li>
                                <li><a href="../classes/GIScene.Control.PanOrbitZoomCenter.html">GIScene.Control.PanOrbitZoomCenter</a></li>
                                <li><a href="../classes/GIScene.Control.Pick.html">GIScene.Control.Pick</a></li>
                                <li><a href="../classes/GIScene.Control.Select.html">GIScene.Control.Select</a></li>
                                <li><a href="../classes/GIScene.Control.SSAO.html">GIScene.Control.SSAO</a></li>
                                <li><a href="../classes/GIScene.Control.TextPanel.html">GIScene.Control.TextPanel</a></li>
                                <li><a href="../classes/GIScene.Control.Trackball.html">GIScene.Control.Trackball</a></li>
                                <li><a href="../classes/GIScene.Control.Walk.html">GIScene.Control.Walk</a></li>
                                <li><a href="../classes/GIscene.Coordinate2.html">GIscene.Coordinate2</a></li>
                                <li><a href="../classes/GIscene.Coordinate3.html">GIscene.Coordinate3</a></li>
                                <li><a href="../classes/GIScene.DirectionMaterial.html">GIScene.DirectionMaterial</a></li>
                                <li><a href="../classes/GIScene.DistanceOpacityMaterial.html">GIScene.DistanceOpacityMaterial</a></li>
                                <li><a href="../classes/GIScene.Extent2.html">GIScene.Extent2</a></li>
                                <li><a href="../classes/GIScene.Format.html">GIScene.Format</a></li>
                                <li><a href="../classes/GIScene.GeoJSONLoader.html">GIScene.GeoJSONLoader</a></li>
                                <li><a href="../classes/GIScene.Grid.html">GIScene.Grid</a></li>
                                <li><a href="../classes/GIScene.Grid.Index.html">GIScene.Grid.Index</a></li>
                                <li><a href="../classes/GIScene.Layer.html">GIScene.Layer</a></li>
                                <li><a href="../classes/GIScene.Layer.Fixed.html">GIScene.Layer.Fixed</a></li>
                                <li><a href="../classes/GIScene.Layer.Grid.html">GIScene.Layer.Grid</a></li>
                                <li><a href="../classes/GIScene.Layer.Helper.html">GIScene.Layer.Helper</a></li>
                                <li><a href="../classes/GIScene.Layer.W3DS_0_4_0.html">GIScene.Layer.W3DS_0_4_0</a></li>
                                <li><a href="../classes/GIScene.Layer.W3DS_0_4_1.html">GIScene.Layer.W3DS_0_4_1</a></li>
                                <li><a href="../classes/GIScene.Line2.html">GIScene.Line2</a></li>
                                <li><a href="../classes/GIScene.LocalFileLoader.html">GIScene.LocalFileLoader</a></li>
                                <li><a href="../classes/GIScene.ModelLoader.html">GIScene.ModelLoader</a></li>
                                <li><a href="../classes/GIScene.OverrideMaterialHandler.html">GIScene.OverrideMaterialHandler</a></li>
                                <li><a href="../classes/GIScene.OverrideMaterialHandler.WMS.html">GIScene.OverrideMaterialHandler.WMS</a></li>
                                <li><a href="../classes/GIScene.PointAlignmentMaterial.html">GIScene.PointAlignmentMaterial</a></li>
                                <li><a href="../classes/GIScene.Process.html">GIScene.Process</a></li>
                                <li><a href="../classes/GIScene.Process.Intervisibility.html">GIScene.Process.Intervisibility</a></li>
                                <li><a href="../classes/GIScene.Process.LineOfSight.html">GIScene.Process.LineOfSight</a></li>
                                <li><a href="../classes/GIScene.Process.LineOfSight_fastClient.html">GIScene.Process.LineOfSight_fastClient</a></li>
                                <li><a href="../classes/GIScene.Process.LineOfSight_Layer.html">GIScene.Process.LineOfSight_Layer</a></li>
                                <li><a href="../classes/GIScene.Process.LineOfSight_simpleClient.html">GIScene.Process.LineOfSight_simpleClient</a></li>
                                <li><a href="../classes/GIScene.Process.LineOfSightNetwork_allToAll.html">GIScene.Process.LineOfSightNetwork_allToAll</a></li>
                                <li><a href="../classes/GIScene.RasterOverlayMaterial.html">GIScene.RasterOverlayMaterial</a></li>
                                <li><a href="../classes/GIScene.Scene.html">GIScene.Scene</a></li>
                                <li><a href="../classes/GIScene.Service.html">GIScene.Service</a></li>
                                <li><a href="../classes/GIScene.Service.W3DS_0_4_0.html">GIScene.Service.W3DS_0_4_0</a></li>
                                <li><a href="../classes/GIScene.Service.W3DS_0_4_1.html">GIScene.Service.W3DS_0_4_1</a></li>
                                <li><a href="../classes/GIScene.Style.html">GIScene.Style</a></li>
                                <li><a href="../classes/GIScene.Utils.html">GIScene.Utils</a></li>
                                <li><a href="../classes/GIScene.WMSOverlayMaterial.html">GIScene.WMSOverlayMaterial</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/GIScene.html">GIScene</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: GIScene\Process\LineOfSight_simpleClient.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * The Line of Sight Process calculates the visibility bewtween two points in the scene
 * 
 * @namespace GIScene
 * @class Process.LineOfSight_simpleClient
 * @constructor
 * @extends GIScene.Process 
 * 
 * @author mcauer https://github.com/mcauer
 */
GIScene.Process.LineOfSight_simpleClient = function() {
	
	var config = {
		identifier		: &quot;GIScene:lineOfSight&quot;,
		title			: &quot;Line of Sight&quot;,
		abstract		: &quot;Given two locations and possible obstacle objects this process will compute the visibility between the two locations and provides a graphical 3D line.&quot;,
		metadata		: null,
		processVersion	: &quot;1.0&quot;,
		description		: {inputs:[
								{
									identifier: &#x27;GIScene:lineOfSight:observerPoint&#x27;,
									title:    &#x27;Observer Point&#x27;, 
									abstract: &#x27;Point of Observer, where the line of sight starts.&#x27;, 
									dataType:  &#x27;GIScene.Coordinate3&#x27;, //long geo coords
									maxOccurs: 1,
								},
								{
									identifier: &#x27;GIScene:lineOfSight:observerOffset&#x27;,
									title:	&#x27;Observer Offset&#x27;,
									abstract:	&#x27;Additional height offset to observer point.&#x27;,
									dataType:	&#x27;Number&#x27;,
									minOccurs: 0,
									maxOccurs: 1,
									defaultValue:0
								},
								{	identifier: &#x27;GIScene:lineOfSight:targetPoint&#x27;,
									title:    &#x27;Tartget Point&#x27;, 
									abstract: &#x27;Point of Target, where the line of sight ends.&#x27;, 
									dataType:   &#x27;GIScene.Coordinate3&#x27;, //long geo coords
									minOccurs: 1,
									maxOccurs: 1
								},
								{
									identifier: &#x27;GIScene:lineOfSight:targetOffset&#x27;,
									title:	&#x27;Target Offset&#x27;,
									abstract:	&#x27;Additional height offset to target point.&#x27;,
									dataType:	&#x27;Number&#x27;,
									minOccurs: 0,
									maxOccurs: 1,
									defaultValue:0
								},
								{
									identifier: &#x27;GIScene:lineOfSight:obstacleLayers&#x27;,
									title:    &#x27;Obstacle Layers&#x27;,
									abstract: &#x27;Layers whose objects are possible obstacles to be reflected in the calculation.&#x27;,
									dataType  : &#x27;Array(GIScene.Layer)&#x27;,
									minOccurs: 1,
									maxOccurs: &#x27;unbounded&#x27; //like in xml
								}
							],
							outputs:[
								{
									identifier: &#x27;GIScene:lineOfSight:lineOfSight&#x27;,
									title:	&#x27;Line Of Sight&#x27;,
									abstract:	&#x27;The calculated Line of Sight between observer and target.&#x27;,
									dataType:	&#x27;THREE.Object3D&#x27; //???
									
								},
								{
									identifier: &#x27;GIScene:lineOfSight:isVisible&#x27;,
									title:	&#x27;Target is visible&#x27;,
									abstract:	&#x27;The result of the visibility calculation.&#x27;,
									dataType:	&#x27;boolean&#x27;
								}
							]
						}
	};
	
	//make this a Process
	GIScene.Process.apply(this, [config]);

	
	//setDefaults	
	this.config.description.inputs.forEach( function(e, i, a) {
		if (e.defaultValue != undefined) {
			//console.log(e, e.defaultValue, e.identifier);
			this.setInput(e.identifier, e.defaultValue);
		}
	}.bind(this)); 
	
	this.raycaster	= new THREE.Raycaster();
	
	var lineMatVisible = new THREE.LineBasicMaterial({color: new THREE.Color(0x00ff00)});
	var lineMatNotVisible = new THREE.LineBasicMaterial({color: new THREE.Color(0xff0000)});
	
	
	
	/**
	 * run the process with the inputs that have been set before
	 *  @method execute
	 *  @param {Function} [onExecute] callback that will be called when process is finished
	 *  
	 */
	
	this.execute = function(onExecute) {
		// var observerV3 		= this.data.inputs[&#x27;GIScene:lineOfSight:observerPoint&#x27;];
		var observerC3 		= this.data.inputs[&#x27;GIScene:lineOfSight:observerPoint&#x27;];
		console.log(&#x27;observerc3&#x27;);
		console.log(observerC3);
		var observerOffset 	= this.data.inputs[&#x27;GIScene:lineOfSight:observerOffset&#x27;];	
		//var targetV3		= this.data.inputs[&#x27;GIScene:lineOfSight:targetPoint&#x27;];
		var targetC3		= this.data.inputs[&#x27;GIScene:lineOfSight:targetPoint&#x27;];
		var targetOffset	= this.data.inputs[&#x27;GIScene:lineOfSight:targetOffset&#x27;];
		var obstacleLayers	= this.data.inputs[&#x27;GIScene:lineOfSight:obstacleLayers&#x27;];	
		
		var onExecute = onExecute || function(){};
		
		//@TODO evaluate inputs (occurences etc.)
		var scene = obstacleLayers[0].scene; // get scene from layers, better set scene as a process param?
		
		//short graphic coords
		var observerV3 		= observerC3.clone().sub(scene.config.offset).toVector3();
		var targetV3		= targetC3.clone().sub(scene.config.offset).toVector3();
		
		var start 		= observerV3.clone().add(new THREE.Vector3(0,observerOffset,0)); //short graphic coords
		var end			= targetV3.clone().add(new THREE.Vector3(0,targetOffset,0));
		var direction 	= end.clone().sub(start).normalize();
		// var loading = new GIScene.Grid.TileStore(); // need it per layer
		var intersections; 
		var nearestIntersection = null;
		var numCheckedLayers = 0;
		var targetIsVisible;
		
		//global analysis state
		var analysisDone= false;
		
		
		this.raycaster.set(start, direction); //(origin, direction) direction must be normalized
		
		this.raycaster.far = start.distanceTo(end);//targetV3.clone().sub(observerV3).length();
		
		console.log(&quot;far&quot;, this.raycaster.far);
		
		/**
		 * 
		 * @method getNearestIntersectionObject
		 * @private
		 * @param {THREE.Vector3} referencePoint
		 * @param {Object} intersectionObjectA object returned from Raycaster.intersectObjects() method
		 * @param {Object} intersectionObjectB object returned from Raycaster.intersectObjects() method
		 * @return {Object} nearestIntersectionObject
		 */
		var getNearestIntersectionObject = function(referencePoint, intersectionObjectA, intersectionObjectB) {
			//only valid if both are created by the same ray
			return ( intersectionObjectA.distance &lt; intersectionObjectB.distance )?
					 intersectionObjectA
					:
					 intersectionObjectB
					;
			
			// return ( referencePoint.distanceTo(intersectionObjectA.point) &lt; referencePoint.distanceTo(intersectionObjectB.point) )?
					  // intersectionObjectA
					 // :
					  // intersectionObjectB
					 // ;
			
		};
		
		//returns true if newIntersection is nearest
		var updateNearestIntersection = function(nearestIntersection_, newIntersection) {
			if ( !!(newIntersection) ){ //intersections found
			  	if(!nearestIntersection){ 
			  		nearestIntersection = newIntersection;
			  		updateAllNearestIntersectionTileIndices();
			  		return true;
			  	}
			  	else{
			  		nearestIntersection = getNearestIntersectionObject(start,nearestIntersection_,newIntersection);
			  		if(nearestIntersection === newIntersection){
			  				updateAllNearestIntersectionTileIndices();
			  				return true;
			  			};
			  		
			  		};
			  	}
			 else { //no intersections found
			 	return false;
			 }
		};
		
		var updateAllNearestIntersectionTileIndices = function() {
			for(var i=0,j=gridLayers.length; i&lt;j; i++){
			  
			  var layer = gridLayers[i];
			  
			  var nearestIntersectionGridIndex = (nearestIntersection)? layer.grid.getIndexFromPoint2d(GIScene.Utils.vector3ToVector2(nearestIntersection.point), layer.LineOfSightAnalysisController.smallestTileSize) : undefined;
			  
			  layer.LineOfSightAnalysisController.analysisTiles.forEach(function(e,idx,a){
								  			if(nearestIntersectionGridIndex &amp;&amp; e.equals(nearestIntersectionGridIndex)){layer.LineOfSightAnalysisController.nearestIntersectionTileIndex = idx;}
								 		}.bind(this)
								 );
			};
		};
		
		
		// //find indexOf first element with true if no undefined is found before, otherwise if 
		// undefined before return -1
		// if no undefined is found and all are false return false
		var getIndexOfFirstIntersectionTile = function(ctrl){
		  var first = false;
		  for (var i=0,j=ctrl.length;i&lt;j;i++){
		
		    if(ctrl[i] === undefined)	{first = -1;	break;}
		    if(ctrl[i] === true)		{first = true;	break;}
		  
		  }
		  return first;
		};
		
		//all from here must be wrapped in a returnResults function
		var returnResults = function(layer/*, loading, computeTileIndicesHandler*/) {
			
			if (layer) {var losCtrl = layer.LineOfSightAnalysisController;}
			if(losCtrl){ //only available in gridLayers
				var computeTileIndicesHandler = losCtrl.computeTileIndicesHandler;
				var loading = losCtrl.loading;	
			}
			
			
			if(layer &amp;&amp; loading){
				//abort all still loading in a finished layer
				var aborts = 0;
				for ( tile in loading.store ){
					loading.store[tile].object.abort();
					aborts++;
					loading.remove(new GIScene.Grid.Index().fromString(tile));
				}
				console.log(layer.name + &quot;: optimized uncached tiles by abort running requests: &quot; + aborts);
			}
			
			//restore original state
		  	if(computeTileIndicesHandler) layer.computeTileIndicesHandler = computeTileIndicesHandler;
			
			//wait until last layer has finished 
			if( !( numCheckedLayers == obstacleLayers.length ) ){
				console.log(&quot;Number of checked Layers&quot;,numCheckedLayers);	
				return;
				}
			
			//all layers are checked now
			analysisDone = true;
			console.log(&quot;Number of checked Layers&quot;,numCheckedLayers, &quot;Ready.&quot;);
			
			
			//return to normal work
			
			gridLayers.forEach(function(layer,i,a){ 
					
					layer.startUpdate(); 
					
					//cleanup
					layer.LineOfSightAnalysisController = null;
					losCtrl = null;
					delete layer.LineOfSightAnalysisController;
					
				});
			
			//evaluate intersections
			console.log(&quot;THE END&quot;);
			
			// var targetIsVisible = true;
			var visibilityLines;
			var group = new THREE.Object3D();
			
			if( nearestIntersection ) { 
				targetIsVisible = false; 
				
				//visLine
				var geomVis = new THREE.Geometry();
				geomVis.vertices = [start,nearestIntersection.point];
				var visLine = new THREE.Line(geomVis, lineMatVisible);
				//notVisLine
				var geomNotVis = new THREE.Geometry();
				geomNotVis.vertices = [nearestIntersection.point,end];
				var notvisLine = new THREE.Line(geomNotVis, lineMatNotVisible);
				
				group.add(visLine);
				group.add(notvisLine);
				}
			else {
				targetIsVisible = true;
				var geom = new THREE.Geometry();
				geom.vertices = [start,end];
				var visLine = new THREE.Line(geom, lineMatVisible);
				
				group.add(visLine);
			}
			
			this.data.outputs[&#x27;GIScene:lineOfSight:lineOfSight&#x27;] = group;
			this.data.outputs[&#x27;GIScene:lineOfSight:isVisible&#x27;]	 = targetIsVisible;
			
			this.dispatchEvent({type:&#x27;execute&#x27;, content : this.data});
			
			onExecute(this.data);
			
		}.bind(this);
		
		var checkUncachedTile = function(index, layer/*, loading, controlArray, uncachedTiles, uncachedTilesIndex, computeTileIndicesHandler,analysisState, nearestIntersectionTileIndex*/) {
			
			var losCtrl = layer.LineOfSightAnalysisController;
			
			var loading = losCtrl.loading;
			var controlArray = losCtrl.controlArray;
			var uncachedTilesIndex = losCtrl.uncachedTilesIndex;
			
			var gridIndex = losCtrl.uncachedTiles[index];
			
						
			var requestUrl = layer.config.service.getGetSceneUrl(gridIndex, layer.grid);
			
			var onSuccess = function(result) { //result is a THREE.Scene Object
				
				
				
				var checkIntersection = true;
				
				console.log(layer.name + &#x27;: LineOfSight:load uncached tiles:onSuccess&#x27;,index);
				
				if (losCtrl.layerChecked){
					console.log(layer.name + &quot;: Analysis already DONE!&quot;);
					return;
				}; //for async callbacks after first intersection already found
				
				//remove from loading
				loading.remove(gridIndex);
				
				//TODO don&#x27;t check intersection if already nearer tile is checked positive (from other uncached tile / layer)
				console.log(&quot;nearestIntersectionTileIndex&quot;,losCtrl.nearestIntersectionTileIndex);
				//short hack only for current layer
				if(index &gt; losCtrl.nearestIntersectionTileIndex) {console.log(&quot;already behind nearest intersection. SKIP processing loaded tile.&quot;);checkIntersection = false;controlArray[uncachedTilesIndex[index]] = false;/*return;*/}
				//long hack across all layers 
				// if(nearestIntersection){
					// var tileCenter = layer.grid.getCentroidFromIndex(gridIndex); //Vec2 short graphic coords
					// // var boundingRadius = Math.sqrt( 2 * Math.pow(gridIndex.tileSize*0.5, 2) );
					// // var nearestIntTileCenterDistance = tileCenter.distanceTo( GIScene.Utils.vector3ToVector2(nearestIntersection.point) );
// 					
					// // if (nearestIntTileCenterDistance &gt; boundingRadius){
						// // console.log(layer.name + &quot;: optimize uncached tiles. Already nearer intersection found. Skip analysisTiles index&quot; + uncachedTilesIndex[index]);
						// // //return false;
						// // checkIntersection = false;
						// // controlArray[uncachedTilesIndex[index]] = false;
					// // }
// 					
					// if( GIScene.Utils.vector3ToVector2(nearestIntersection.point.clone().sub(start)).length() &lt; tileCenter.clone().sub(GIScene.Utils.vector3ToVector2(start)).length() ){
						// console.log(layer.name + &quot;: optimize uncached tiles. Already nearer intersection found. Skip analysisTiles index&quot; + uncachedTilesIndex[index]);
						// //return false;
						// // return; 
						// checkIntersection = false;
						// controlArray[uncachedTilesIndex[index]] = false;
					// }
				// }
				
				if (checkIntersection){
					//rotate model if z is up
					if(layer.verticalAxis.toUpperCase() == &quot;Z&quot;){
						result.applyMatrix( new THREE.Matrix4().makeRotationX( -Math.PI/2 ) );
					}
					
					//setOverrideMaterial
					layer.setOverrideMaterial(result, layer.config.overrideMaterial);
					
					layer.root.add(result);
			  		result.updateMatrixWorld();
			  		
			  		//TODO OPTIONALLY compute BBOX
			  		result.traverse(function(object){if(object.geometry){object.geometry.computeBoundingBox();}});
			  		
			  		//TODO may be wait for after render, so that everything is updated correctly?
			  		intersections = this.raycaster.intersectObject(layer.root, true);
			  		
			  		//TODO if no obstruction point needed then if intersections.length &gt; 0 indicates visibility false and the whole process can be stopped here
			  		if(intersections.length &gt; 0){
				  		var isNearestTile = updateNearestIntersection(nearestIntersection, intersections[0]);
				  		
				  		if(isNearestTile){losCtrl.nearestIntersectionTileIndex = uncachedTilesIndex[index]; }
				  		console.log(&quot;nearestIntersectionTileIndex&quot;, losCtrl.nearestIntersectionTileIndex);
				  		
				  		controlArray[uncachedTilesIndex[index]] = true;
			  		}
			  		else{
			  			controlArray[uncachedTilesIndex[index]] = false;
			  		}
			  		layer.root.remove(result);
				}
				
		  		
		  		//add tile to cache to make use of having loaded it for after analysis visualization
		  		layer.cache.add(gridIndex,result);
				
			//if there is no tile before left to be checked and an intersection was found here: continue the loop to the next layer
			//check if all tiles have been tested then execute returnResults()
			var firstIntersectionTile = getIndexOfFirstIntersectionTile(controlArray);
			console.log(&quot;doreturnResults?&quot;, firstIntersectionTile !== -1);
			console.log(&quot;intersectionsLength: &quot;, intersections.length);
			console.log(&quot;Loading Requests:&quot; , loading.length);
			if(firstIntersectionTile !== -1){
				numCheckedLayers++;
				losCtrl.layerChecked = true;
				console.log(layer.name +&quot; : firstIntersection found! Layer checked by UNCACHED!&quot;);
				returnResults(layer/*, loading, computeTileIndicesHandler*/);
			}
			
			
			}.bind(this);
			
			var onError = function(event) {
				console.log(event);
				
				console.log(layer.name + &#x27;: LineOfSight:load uncached tiles:onError&#x27;,index);
				
				//remove from loading
				loading.remove(gridIndex);
				alert (&quot;XHRError&quot;);
								
			}.bind(this);//TODO Sceneloader will never throw it // now it should
			
			var loader = new GIScene.ModelLoader(); //need a loader for every parallel request
			loader.load(requestUrl, layer.format, onSuccess, undefined, onError);
			loading.add(gridIndex,loader);
		}.bind(this);
		
		
		/////////////////////
		// START ANALIZING //
		/////////////////////
		
		//get layers to be included in analysis
				
		//find out which are Grid and which not
		var gridLayers = [];
		var staticLayers = [];
		obstacleLayers.forEach(function(e,i,a){
			if (e instanceof GIScene.Layer.Grid){gridLayers.push(e);}
			else {staticLayers.push(e);}
		});
		
		console.log(&quot;obstacle layers&quot;, obstacleLayers.length);
		console.log(&quot;static layers&quot;, staticLayers.length);
		console.log(&quot;grid layers&quot;, gridLayers.length);
		
		//first check the STATIC layers then the more complicated gridLayers
		for(var i=0,j=staticLayers.length; i&lt;j; i++){
		  
		  intersections = this.raycaster.intersectObject(staticLayers[i].root, true);
		  
		  //TODO if no obstruction point needed then if intersections.length &gt; 0 indicates visibility false and the whole process can be stopped here
		  
		  //check which intersection is the first (nearest to start)
		  if(intersections.length &gt; 0) updateNearestIntersection(nearestIntersection, intersections[0]);
		  
		  numCheckedLayers++;
		  console.log(staticLayers[i].name +&quot; : Layer checked STATIC!&quot;);
		  returnResults();
		  
		}; //static layer check end
		
		
		
		//INIT gridlayers checking for checking
		for(var i=0,j=gridLayers.length; i&lt;j; i++){
			
			var layer = gridLayers[i];
			var grid = layer.grid;
			
			//controller object for each grid layer
			layer.LineOfSightAnalysisController = {};
		  	var losCtrl = layer.LineOfSightAnalysisController;
		  		  
		  	losCtrl.layerChecked = false;
		  	losCtrl.loading = new GIScene.Grid.TileStore();
		    losCtrl.smallestTileSize = grid.tileSizes[grid.tileSizes.length-1]; //tilesizes are sorted from big to small
		    
		    //get AnalysisTiles per layer
			var observerV2 = new GIScene.Coordinate2().fromVector2( GIScene.Utils.vector3ToVector2(observerV3.clone().add(grid._sceneOffset)) );
			var targetV2 =   new GIScene.Coordinate2().fromVector2( GIScene.Utils.vector3ToVector2(  targetV3.clone().add(grid._sceneOffset)) );
			  
			var optimizedTarget1 = (nearestIntersection)? new GIScene.Coordinate2().fromVector2( GIScene.Utils.vector3ToVector2(  nearestIntersection.point.clone().add(grid._sceneOffset)) ) : targetV2;
			//8-connected rasterline (DDA grid traversal algorithm)
			var woOptimizedTarget = grid.getTilesFromLineIntersection(observerV2,targetV2,losCtrl.smallestTileSize);
			losCtrl.analysisTiles = grid.getTilesFromLineIntersection(observerV2,optimizedTarget1,losCtrl.smallestTileSize);
			  
			console.log(layer.name + &quot;: &quot;+ optimizedTarget1.toArray());
			console.log(layer.name + &quot;: optimized number of tiles: &quot; + losCtrl.analysisTiles.length +&quot;/&quot;+ woOptimizedTarget.length + &quot; &quot; + ((losCtrl.analysisTiles.length *100) / woOptimizedTarget.length) + &quot;%&quot;);
			
			losCtrl.controlArray = new Array(losCtrl.analysisTiles.length);
 
			//check each analysisTile for obstructions: first chached tiles synchronously, then uncached tiles asnchronuously
			//tiles have to be loaded and added to the scene, to be sure that all matrices are applied correctly when tested with Raycaster

			//store layer function to be restored after the analysis
			losCtrl.computeTileIndicesHandler = layer.computeTileIndicesHandler;

			// remove all tiles
			//better in future: remove tiles in two steps to be sure that the analysis tile get into the cache at last
			layer.stopUpdate();
			layer.computeTileIndicesHandler = function() {
				return [];
			};
			layer.update();
			//this removes all tiles from the scene

			//first check available tiles from cache
			losCtrl.cachedTiles = [];	//Objects
			losCtrl.cachedTilesIndex = [];
			losCtrl.uncachedTiles = [];	//TileIndex
			losCtrl.uncachedTilesIndex = [];

			//var nearestIntersectionTileIndex;//analysisTiles Array Index
			losCtrl.nearestIntersectionTileIndex = undefined;

			losCtrl.analysisTiles.forEach( function(e, i, a) {

				var tileFromCache = layer.cache.getTile(e);
				if (tileFromCache) {
					losCtrl.cachedTiles.push(tileFromCache);  //Object3D
					losCtrl.cachedTilesIndex.push(i);
				} else {
					losCtrl.uncachedTiles.push(e);  	//Grid.Index
					losCtrl.uncachedTilesIndex.push(i);
				}
			}.bind(this));

			console.log(layer.name + &quot;: cached / uncached tiles&quot;, losCtrl.cachedTiles.length, losCtrl.uncachedTiles.length); 

			
		}
		
		//////////////////////////////////////////////////////////// 
		//START checking ALL gridlayers CACHED tiles synchronously//
		////////////////////////////////////////////////////////////
		for(var i=0,j=gridLayers.length; i&lt;j; i++){
		  
		  var layer = gridLayers[i];
		  var losCtrl = layer.LineOfSightAnalysisController;
		  
		  	  
		  console.log(&quot;Start Analyzing &quot; + layer.name);
		  console.log(layer.name + &quot;: Analyzing &quot;+ losCtrl.cachedTiles.length +&quot; CACHED tiles&quot;);
		  
		  
		  // CHECK CACHED TILES
		  for(var iiii=0,jjjj=losCtrl.cachedTiles.length; iiii&lt;jjjj; iiii++){
		  	
		  	var tileFromCache = losCtrl.cachedTiles[iiii];
		  	
		  	layer.root.add(tileFromCache);
		  		
	  		//TODO may be wait for after render, so that everything is updated correctly?
	  		intersections = this.raycaster.intersectObject(layer.root, true);
	  		
	  		//TODO if no obstruction point needed then if intersections.length &gt; 0 indicates visibility false and the whole process can be stopped here
	  		if(intersections.length &gt; 0){
	  			var isNearestTile = updateNearestIntersection(nearestIntersection, intersections[0]);
	  		
	  			if(isNearestTile){losCtrl.nearestIntersectionTileIndex = losCtrl.cachedTilesIndex[iiii]; }
	  			console.log(&quot;nearestIntersectionTileIndex&quot;, losCtrl.nearestIntersectionTileIndex);
	  			losCtrl.controlArray[losCtrl.cachedTilesIndex[iiii]] = true;
	  		}
	  		else{
	  			losCtrl.controlArray[losCtrl.cachedTilesIndex[iiii]] = false;
	  		}
	  		
	  		layer.root.remove(tileFromCache);
	  		
	  		var firstIntersectionTile = getIndexOfFirstIntersectionTile(losCtrl.controlArray); // true (first found), false (all checked but none found) or -1 (keep on checking)
	  		console.log(layer.name + &#x27; :firstIntersectionTile&#x27;, firstIntersectionTile, losCtrl.controlArray.length);
	  		if(firstIntersectionTile !== -1){
	  			numCheckedLayers++;
	  			console.log(layer.name +&quot; : firstIntersection found! Layer checked by CACHED!&quot;);
				returnResults(layer/*, loading, computeTileIndicesHandler*/);
				
				losCtrl.layerChecked = true;
				break; //no more cached tile testing
			}
		  };
		  //if(layerChecked){continue;} //when checked by cached no testing of uncached --&gt; test next layer
		  
		} //DONE checking all gridlayers CACHED tiles
		  
		 
		 if( analysisDone ) return; 
		  
		 ///////////////////////////////////////////////////////////////
		 //START checking ALL gridlayers UNCACHED tiles asynchronously//
		 ///////////////////////////////////////////////////////////////
		 for(var i=0,j=gridLayers.length; i&lt;j; i++){ 
		  
		  var layer = gridLayers[i];
		  var losCtrl = layer.LineOfSightAnalysisController;
		  if (losCtrl.layerChecked){ return; };
		  //OPTIMIZE
		  //reduce uncachedTiles according to former found intersections
		  //2nd reduction if uncached are left but found intersection in cached
		  if(nearestIntersection){
		  	var deleteFromIndex = null;
		  	for(var iii=losCtrl.uncachedTilesIndex.length-1, jjj=0; iii&gt;=jjj; iii--){
				if(losCtrl.uncachedTilesIndex[iii] &gt;= losCtrl.nearestIntersectionTileIndex){
					deleteFromIndex = iii;
				}
			  };
			  
			 if(deleteFromIndex != null){
			 	console.log(&#x27;controlArray:before&#x27;, losCtrl.controlArray);
			 	var uncached_orig_length = losCtrl.uncachedTiles.length;
			 	
			 	losCtrl.uncachedTiles.splice(deleteFromIndex,Number.MAX_VALUE); //???
			 	
			 	//update controlArray
			 	for(var v = deleteFromIndex, vi = uncached_orig_length/*uncachedTiles.length*/; v &lt; vi; v++){
			 		losCtrl.controlArray[losCtrl.uncachedTilesIndex[v]] = false;
			 	}
			 	
			 	//update uncachedTilesIndex
			 	losCtrl.uncachedTilesIndex.splice(deleteFromIndex,Number.MAX_VALUE); //???
			 	 
			 	console.log(layer.name + &quot;: optimized number of uncached tiles: &quot; + uncached_orig_length +&quot;--&gt;&quot;+ losCtrl.uncachedTiles.length);
			 	// console.log(&#x27;controlArray:after&#x27;, losCtrl.controlArray);
			 }
		  }
		  
		  
		  //CHECK remaining UNCACHED tiles (async)
		  console.log(layer.name + &quot;: Analyzing &quot;+ losCtrl.uncachedTiles.length +&quot; UNCACHED tiles&quot;);
		  for(var ii=0,jj=losCtrl.uncachedTiles.length; ii&lt;jj; ii++){
					
			if (checkUncachedTile(ii, layer/*, loading, controlArray, uncachedTiles, uncachedTilesIndex,computeTileIndicesHandler,analysisState, nearestIntersectionTileIndex*/) === false) { continue; }
			
		  };
		  
		  
		}; // gridLayer check end
		
	};
		
};

//Inherit from GIScene.Layer
GIScene.Process.LineOfSight_simpleClient.prototype = Object.create( GIScene.Process.prototype );
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
